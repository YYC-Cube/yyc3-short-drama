---
@file: 049-YYC3-Short-Drama-è¯¦ç»†è®¾è®¡-å¼‚å¸¸å¤„ç†ä»£ç è§„èŒƒ.md
@description: YYC3-Short-Drama ç³»ç»Ÿå…¨å±€å¼‚å¸¸ã€ä¸šåŠ¡å¼‚å¸¸ã€æŠ€æœ¯å¼‚å¸¸çš„å¤„ç†è§„èŒƒä¸ä»£ç å®ç°
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2025-12-31
@updated: 2025-12-31
@status: published
@tags: [è¯¦ç»†è®¾è®¡],[å¼‚å¸¸å¤„ç†],[å®¹é”™è®¾è®¡]
---

> ***YanYuCloudCube***
> è¨€å¯è±¡é™ | è¯­æ¢æœªæ¥
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> ä¸‡è±¡å½’å…ƒäºäº‘æ¢ | æ·±æ ˆæ™ºå¯æ–°çºªå…ƒ
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 049-YYC3-Short-Drama-è¯¦ç»†è®¾è®¡-å¼‚å¸¸å¤„ç†ä»£ç è§„èŒƒ

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°YYC3-Short-Drama-è¯¦ç»†è®¾è®¡-å¼‚å¸¸å¤„ç†ä»£ç è§„èŒƒç›¸å…³å†…å®¹ï¼Œç¡®ä¿é¡¹ç›®æŒ‰ç…§YYCÂ³æ ‡å‡†è§„èŒƒè¿›è¡Œå¼€å‘å’Œå®æ–½ã€‚

## æ ¸å¿ƒå†…å®¹

### 1. èƒŒæ™¯ä¸ç›®æ ‡

#### 1.1 é¡¹ç›®èƒŒæ™¯
YYC3-Short-Dramaé¡¹ç›®æ˜¯ä¸€ä¸ªåŸºäºã€Œäº”é«˜äº”æ ‡äº”åŒ–ã€ç†å¿µçš„æ²³æ´›æ–‡åŒ–æ•°å­—ä¼ æ‰¿åˆ›æ–°å¹³å°ï¼Œè‡´åŠ›äºè¿ç”¨ç°ä»£ç§‘æŠ€æ‰‹æ®µä¼ æ‰¿å’Œå¼˜æ‰¬æ²³æ´›æ–‡åŒ–ï¼Œæ‰“é€ æ²³æ´›æ–‡åŒ–æ•°å­—ä¼ æ‰¿å¹³å°ã€‚å¹³å°èåˆäººå·¥æ™ºèƒ½ã€è™šæ‹Ÿç°å®ã€åŒºå—é“¾ç­‰å‰æ²¿æŠ€æœ¯ï¼Œä»¥æ´›é˜³ä¸ºæ ¸å¿ƒï¼Œæ·±åº¦æŒ–æ˜æ²³æ´›æ–‡åŒ–çš„å†å²åº•è•´ã€‚

#### 1.2 æ–‡æ¡£ç›®æ ‡
- è§„èŒƒå¼‚å¸¸å¤„ç†ä»£ç è§„èŒƒç›¸å…³çš„ä¸šåŠ¡æ ‡å‡†ä¸æŠ€æœ¯è½åœ°è¦æ±‚
- ä¸ºé¡¹ç›®ç›¸å…³äººå‘˜æä¾›æ¸…æ™°çš„å‚è€ƒä¾æ®
- ä¿éšœç›¸å…³æ¨¡å—å¼€å‘ã€å®æ–½ã€è¿ç»´çš„ä¸€è‡´æ€§ä¸è§„èŒƒæ€§

### 2. è®¾è®¡åŸåˆ™

#### 2.1 äº”é«˜åŸåˆ™
- **é«˜å¯ç”¨æ€§**ï¼šç¡®ä¿ç³»ç»Ÿ7x24å°æ—¶ç¨³å®šè¿è¡Œï¼Œä¿éšœç”¨æˆ·ä½“éªŒ
- **é«˜æ€§èƒ½**ï¼šä¼˜åŒ–å“åº”æ—¶é—´å’Œå¤„ç†èƒ½åŠ›ï¼Œæå‡ç³»ç»Ÿæ•ˆç‡
- **é«˜å®‰å…¨æ€§**ï¼šä¿æŠ¤ç”¨æˆ·æ•°æ®å’Œéšç§å®‰å…¨ï¼Œå»ºç«‹å¤šå±‚æ¬¡å®‰å…¨é˜²æŠ¤
- **é«˜æ‰©å±•æ€§**ï¼šæ”¯æŒä¸šåŠ¡å¿«é€Ÿæ‰©å±•ï¼Œé€‚åº”æœªæ¥å‘å±•éœ€æ±‚
- **é«˜å¯ç»´æŠ¤æ€§**ï¼šä¾¿äºåç»­ç»´æŠ¤å’Œå‡çº§ï¼Œé™ä½è¿ç»´æˆæœ¬

#### 2.2 äº”æ ‡ä½“ç³»
- **æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€çš„æŠ€æœ¯å’Œæµç¨‹æ ‡å‡†ï¼Œç¡®ä¿é¡¹ç›®è´¨é‡
- **è§„èŒƒåŒ–**ï¼šä¸¥æ ¼çš„å¼€å‘å’Œç®¡ç†è§„èŒƒï¼Œæé«˜å¼€å‘æ•ˆç‡
- **è‡ªåŠ¨åŒ–**ï¼šæé«˜å¼€å‘æ•ˆç‡å’Œè´¨é‡ï¼Œå‡å°‘äººä¸ºé”™è¯¯
- **æ™ºèƒ½åŒ–**ï¼šåˆ©ç”¨AIæŠ€æœ¯æå‡èƒ½åŠ›ï¼Œå®ç°æ™ºèƒ½å†³ç­–
- **å¯è§†åŒ–**ï¼šç›´è§‚çš„ç›‘æ§å’Œç®¡ç†ç•Œé¢ï¼Œä¾¿äºç³»ç»Ÿè¿ç»´

#### 2.3 äº”åŒ–æ¶æ„
- **æµç¨‹åŒ–**ï¼šæ ‡å‡†åŒ–çš„å¼€å‘æµç¨‹ï¼Œç¡®ä¿é¡¹ç›®æœ‰åºè¿›è¡Œ
- **æ–‡æ¡£åŒ–**ï¼šå®Œå–„çš„æ–‡æ¡£ä½“ç³»ï¼Œæé«˜é¡¹ç›®å¯è¿½æº¯æ€§
- **å·¥å…·åŒ–**ï¼šé«˜æ•ˆçš„å¼€å‘å·¥å…·é“¾ï¼Œæå‡å¼€å‘æ•ˆç‡
- **æ•°å­—åŒ–**ï¼šæ•°æ®é©±åŠ¨çš„å†³ç­–ï¼Œæé«˜å†³ç­–å‡†ç¡®æ€§
- **ç”Ÿæ€åŒ–**ï¼šå¼€æ”¾çš„ç”Ÿæ€ç³»ç»Ÿï¼Œä¿ƒè¿›é¡¹ç›®å¯æŒç»­å‘å±•

### 3. å¼‚å¸¸å¤„ç†ä»£ç è§„èŒƒ

#### 3.1 å¼‚å¸¸åˆ†ç±»ä½“ç³»

##### 3.1.1 å¼‚å¸¸å±‚çº§ç»“æ„

```
BaseError (åŸºç¡€é”™è¯¯ç±»)
â”œâ”€â”€ BusinessError (ä¸šåŠ¡é”™è¯¯)
â”‚   â”œâ”€â”€ ValidationError (éªŒè¯é”™è¯¯)
â”‚   â”œâ”€â”€ NotFoundError (èµ„æºæœªæ‰¾åˆ°é”™è¯¯)
â”‚   â”œâ”€â”€ ConflictError (å†²çªé”™è¯¯)
â”‚   â”œâ”€â”€ UnauthorizedError (æœªæˆæƒé”™è¯¯)
â”‚   â”œâ”€â”€ ForbiddenError (ç¦æ­¢è®¿é—®é”™è¯¯)
â”‚   â””â”€â”€ PaymentError (æ”¯ä»˜é”™è¯¯)
â”œâ”€â”€ TechnicalError (æŠ€æœ¯é”™è¯¯)
â”‚   â”œâ”€â”€ DatabaseError (æ•°æ®åº“é”™è¯¯)
â”‚   â”œâ”€â”€ NetworkError (ç½‘ç»œé”™è¯¯)
â”‚   â”œâ”€â”€ ExternalServiceError (å¤–éƒ¨æœåŠ¡é”™è¯¯)
â”‚   â”œâ”€â”€ FileSystemError (æ–‡ä»¶ç³»ç»Ÿé”™è¯¯)
â”‚   â””â”€â”€ CacheError (ç¼“å­˜é”™è¯¯)
â””â”€â”€ SystemError (ç³»ç»Ÿé”™è¯¯)
    â”œâ”€â”€ ConfigurationError (é…ç½®é”™è¯¯)
    â”œâ”€â”€ DependencyError (ä¾èµ–é”™è¯¯)
    â””â”€â”€ RuntimeError (è¿è¡Œæ—¶é”™è¯¯)
```

##### 3.1.2 å¼‚å¸¸é”™è¯¯ç è§„èŒƒ

é”™è¯¯ç æ ¼å¼ï¼š`YYC3-ERROR-[æ¨¡å—]-[é”™è¯¯ç±»å‹]-[å…·ä½“é”™è¯¯]`

| æ¨¡å—ä»£ç  | æ¨¡å—åç§° | é”™è¯¯ç±»å‹ä»£ç  | é”™è¯¯ç±»å‹ |
|---------|---------|------------|---------|
| AUTH | è®¤è¯æˆæƒ | 01 | éªŒè¯é”™è¯¯ |
| USER | ç”¨æˆ·ç®¡ç† | 02 | èµ„æºæœªæ‰¾åˆ° |
| DRAMA | çŸ­å‰§ç®¡ç† | 03 | å†²çªé”™è¯¯ |
| PAYMENT | æ”¯ä»˜ç³»ç»Ÿ | 04 | æœªæˆæƒé”™è¯¯ |
| AI | AIæœåŠ¡ | 05 | ç¦æ­¢è®¿é—®é”™è¯¯ |
| FILE | æ–‡ä»¶æœåŠ¡ | 06 | æ•°æ®åº“é”™è¯¯ |
| NOTIFICATION | é€šçŸ¥æœåŠ¡ | 07 | ç½‘ç»œé”™è¯¯ |
| ANALYTICS | æ•°æ®åˆ†æ | 08 | å¤–éƒ¨æœåŠ¡é”™è¯¯ |
| SYSTEM | ç³»ç»Ÿæ ¸å¿ƒ | 09 | æ–‡ä»¶ç³»ç»Ÿé”™è¯¯ |
| 10 | ç¼“å­˜é”™è¯¯ |

ç¤ºä¾‹é”™è¯¯ç ï¼š
- `YYC3-ERROR-AUTH-01-001`ï¼šè®¤è¯æ¨¡å—éªŒè¯é”™è¯¯-é‚®ç®±æ ¼å¼ä¸æ­£ç¡®
- `YYC3-ERROR-USER-02-001`ï¼šç”¨æˆ·æ¨¡å—èµ„æºæœªæ‰¾åˆ°é”™è¯¯-ç”¨æˆ·ä¸å­˜åœ¨
- `YYC3-ERROR-PAYMENT-06-001`ï¼šæ”¯ä»˜æ¨¡å—æ•°æ®åº“é”™è¯¯-æ”¯ä»˜è®°å½•åˆ›å»ºå¤±è´¥

#### 3.2 å¼‚å¸¸å¤„ç†æ¶æ„è®¾è®¡

##### 3.2.1 å‰ç«¯å¼‚å¸¸å¤„ç†æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å‰ç«¯åº”ç”¨å±‚                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç»„ä»¶çº§å¼‚å¸¸æ•è· (Error Boundary)         â”‚
â”‚  â”œâ”€â”€ React Error Boundary                â”‚
â”‚  â”œâ”€â”€ Vue Error Handler                   â”‚
â”‚  â””â”€â”€ Angular ErrorHandler                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å…¨å±€å¼‚å¸¸å¤„ç†å™¨                          â”‚
â”‚  â”œâ”€â”€ window.onerror                      â”‚
â”‚  â”œâ”€â”€ window.onunhandledrejection         â”‚
â”‚  â””â”€â”€ æ¡†æ¶å…¨å±€å¼‚å¸¸å¤„ç†å™¨                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  APIè¯·æ±‚å¼‚å¸¸æ‹¦æˆª                          â”‚
â”‚  â”œâ”€â”€ Axios Interceptor                   â”‚
â”‚  â”œâ”€â”€ Fetch Wrapper                       â”‚
â”‚  â””â”€â”€ è¯·æ±‚é‡è¯•æœºåˆ¶                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¼‚å¸¸æ—¥å¿—ä¸ŠæŠ¥                            â”‚
â”‚  â”œâ”€â”€ Sentryé›†æˆ                          â”‚
â”‚  â”œâ”€â”€ è‡ªå®šä¹‰æ—¥å¿—ä¸ŠæŠ¥                       â”‚
â”‚  â””â”€â”€ ç”¨æˆ·åé¦ˆæ”¶é›†                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### 3.2.2 åç«¯å¼‚å¸¸å¤„ç†æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           åç«¯æœåŠ¡å±‚                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ§åˆ¶å™¨å±‚å¼‚å¸¸æ•è·                         â”‚
â”‚  â”œâ”€â”€ è·¯ç”±çº§å¼‚å¸¸å¤„ç†                       â”‚
â”‚  â”œâ”€â”€ ä¸­é—´ä»¶å¼‚å¸¸æ•è·                       â”‚
â”‚  â””â”€â”€ å…¨å±€å¼‚å¸¸å¤„ç†å™¨                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æœåŠ¡å±‚å¼‚å¸¸å¤„ç†                           â”‚
â”‚  â”œâ”€â”€ ä¸šåŠ¡å¼‚å¸¸æŠ›å‡º                         â”‚
â”‚  â”œâ”€â”€ å¼‚å¸¸è½¬æ¢ä¸åŒ…è£…                       â”‚
â”‚  â””â”€â”€ å¼‚å¸¸é“¾ä¼ é€’                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ•°æ®è®¿é—®å±‚å¼‚å¸¸å¤„ç†                       â”‚
â”‚  â”œâ”€â”€ æ•°æ®åº“å¼‚å¸¸æ•è·                       â”‚
â”‚  â”œâ”€â”€ ORMå¼‚å¸¸å¤„ç†                         â”‚
â”‚  â””â”€â”€ äº‹åŠ¡å›æ»šæœºåˆ¶                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¤–éƒ¨æœåŠ¡å¼‚å¸¸å¤„ç†                         â”‚
â”‚  â”œâ”€â”€ HTTPå®¢æˆ·ç«¯å¼‚å¸¸                       â”‚
â”‚  â”œâ”€â”€ ç¬¬ä¸‰æ–¹SDKå¼‚å¸¸                        â”‚
â”‚  â””â”€â”€ è¶…æ—¶ä¸é‡è¯•æœºåˆ¶                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¼‚å¸¸æ—¥å¿—ä¸ç›‘æ§                           â”‚
â”‚  â”œâ”€â”€ ç»“æ„åŒ–æ—¥å¿—è®°å½•                       â”‚
â”‚  â”œâ”€â”€ é”™è¯¯è¿½è¸ªç³»ç»Ÿ                         â”‚
â”‚  â””â”€â”€ å‘Šè­¦é€šçŸ¥æœºåˆ¶                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.3 å‰ç«¯å¼‚å¸¸å¤„ç†å®ç°

##### 3.3.1 åŸºç¡€é”™è¯¯ç±»å®šä¹‰

```typescript
// shared/errors/base.error.ts
export class BaseError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly timestamp: Date;
  public readonly context?: Record<string, any>;

  constructor(
    message: string,
    code: string,
    statusCode: number,
    context?: Record<string, any>
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.timestamp = new Date();
    this.context = context;

    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      statusCode: this.statusCode,
      timestamp: this.timestamp.toISOString(),
      context: this.context,
      stack: process.env.NODE_ENV === 'development' ? this.stack : undefined,
    };
  }
}
```

##### 3.3.2 ä¸šåŠ¡é”™è¯¯ç±»å®šä¹‰

```typescript
// shared/errors/business.error.ts
import { BaseError } from './base.error';

export class BusinessError extends BaseError {
  constructor(
    message: string,
    code: string,
    statusCode: number = 400,
    context?: Record<string, any>
  ) {
    super(message, code, statusCode, context);
  }
}

export class ValidationError extends BusinessError {
  constructor(message: string, field?: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-VALIDATION-001';
    super(message, code, 400, { ...context, field });
  }
}

export class NotFoundError extends BusinessError {
  constructor(resource: string, id?: string, context?: Record<string, any>) {
    const message = id ? `${resource} with id ${id} not found` : `${resource} not found`;
    const code = 'YYC3-ERROR-NOTFOUND-001';
    super(message, code, 404, { ...context, resource, id });
  }
}

export class ConflictError extends BusinessError {
  constructor(message: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-CONFLICT-001';
    super(message, code, 409, context);
  }
}

export class UnauthorizedError extends BusinessError {
  constructor(message: string = 'Unauthorized', context?: Record<string, any>) {
    const code = 'YYC3-ERROR-UNAUTHORIZED-001';
    super(message, code, 401, context);
  }
}

export class ForbiddenError extends BusinessError {
  constructor(message: string = 'Forbidden', context?: Record<string, any>) {
    const code = 'YYC3-ERROR-FORBIDDEN-001';
    super(message, code, 403, context);
  }
}

export class PaymentError extends BusinessError {
  constructor(message: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-PAYMENT-001';
    super(message, code, 400, context);
  }
}
```

##### 3.3.3 æŠ€æœ¯é”™è¯¯ç±»å®šä¹‰

```typescript
// shared/errors/technical.error.ts
import { BaseError } from './base.error';

export class TechnicalError extends BaseError {
  constructor(
    message: string,
    code: string,
    statusCode: number = 500,
    context?: Record<string, any>
  ) {
    super(message, code, statusCode, context);
  }
}

export class DatabaseError extends TechnicalError {
  constructor(message: string, query?: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-DATABASE-001';
    super(message, code, 500, { ...context, query });
  }
}

export class NetworkError extends TechnicalError {
  constructor(message: string, url?: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-NETWORK-001';
    super(message, code, 502, { ...context, url });
  }
}

export class ExternalServiceError extends TechnicalError {
  constructor(service: string, message: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-EXTERNAL-001';
    super(`${service} service error: ${message}`, code, 502, { ...context, service });
  }
}

export class FileSystemError extends TechnicalError {
  constructor(message: string, path?: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-FILESYSTEM-001';
    super(message, code, 500, { ...context, path });
  }
}

export class CacheError extends TechnicalError {
  constructor(message: string, key?: string, context?: Record<string, any>) {
    const code = 'YYC3-ERROR-CACHE-001';
    super(message, code, 500, { ...context, key });
  }
}
```

##### 3.3.4 å‰ç«¯å…¨å±€å¼‚å¸¸å¤„ç†å™¨

```typescript
// frontend/utils/errorHandler.ts
import { BaseError, ValidationError, UnauthorizedError, ForbiddenError, NotFoundError } from '@/shared/errors';

export interface ErrorHandlerContext {
  showError: (message: string) => void;
  showNotification: (message: string, type: 'error' | 'warning' | 'info') => void;
  redirectTo?: (path: string) => void;
  logError?: (error: Error) => void;
}

export class FrontendErrorHandler {
  private context: ErrorHandlerContext;

  constructor(context: ErrorHandlerContext) {
    this.context = context;
  }

  handleError(error: unknown): void {
    console.error('Frontend Error:', error);

    if (error instanceof BaseError) {
      this.handleBusinessError(error);
    } else if (error instanceof Error) {
      this.handleGenericError(error);
    } else {
      this.handleUnknownError(error);
    }

    this.logError(error);
  }

  private handleBusinessError(error: BaseError): void {
    switch (error.constructor) {
      case ValidationError:
        this.context.showError(error.message);
        break;
      case UnauthorizedError:
        this.context.showNotification('è¯·å…ˆç™»å½•', 'error');
        this.context.redirectTo?.('/login');
        break;
      case ForbiddenError:
        this.context.showNotification('æ²¡æœ‰æƒé™è®¿é—®', 'error');
        this.context.redirectTo?.('/403');
        break;
      case NotFoundError:
        this.context.showNotification('èµ„æºä¸å­˜åœ¨', 'error');
        this.context.redirectTo?.('/404');
        break;
      default:
        this.context.showError(error.message);
    }
  }

  private handleGenericError(error: Error): void {
    this.context.showError('ç³»ç»Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
  }

  private handleUnknownError(error: unknown): void {
    this.context.showError('å‘ç”ŸæœªçŸ¥é”™è¯¯');
  }

  private logError(error: unknown): void {
    if (this.context.logError) {
      this.context.logError(error instanceof Error ? error : new Error(String(error)));
    }
  }
}

export const createErrorHandler = (context: ErrorHandlerContext) => {
  return new FrontendErrorHandler(context);
};
```

##### 3.3.5 React Error Boundaryç»„ä»¶

```typescript
// frontend/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { createErrorHandler } from '@/utils/errorHandler';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private errorHandler = createErrorHandler({
    showError: (message) => {
      console.error('Error Boundary:', message);
    },
    showNotification: (message, type) => {
      console.log(`[${type}] ${message}`);
    },
    redirectTo: (path) => {
      window.location.href = path;
    },
    logError: (error) => {
      console.error('Logged error:', error);
    },
  });

  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('Error Boundary caught an error:', error, errorInfo);

    this.errorHandler.handleError(error);

    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="yyc-error-boundary">
          <div className="yyc-error-boundary__content">
            <h1>å‡ºé”™äº†</h1>
            <p>æŠ±æ­‰ï¼Œé¡µé¢å‘ç”Ÿäº†é”™è¯¯</p>
            <button onClick={() => window.location.reload()}>åˆ·æ–°é¡µé¢</button>
            <button onClick={() => window.history.back()}>è¿”å›ä¸Šä¸€é¡µ</button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

##### 3.3.6 å…¨å±€å¼‚å¸¸ç›‘å¬å™¨

```typescript
// frontend/utils/globalErrorListener.ts
import { createErrorHandler } from './errorHandler';

export const setupGlobalErrorListeners = () => {
  const errorHandler = createErrorHandler({
    showError: (message) => {
      alert(message);
    },
    showNotification: (message, type) => {
      console.log(`[${type}] ${message}`);
    },
    redirectTo: (path) => {
      window.location.href = path;
    },
    logError: (error) => {
      console.error('Global error:', error);
    },
  });

  window.onerror = (message, source, lineno, colno, error) => {
    console.error('Global error caught:', { message, source, lineno, colno, error });
    errorHandler.handleError(error || new Error(String(message)));
    return false;
  };

  window.onunhandledrejection = (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    errorHandler.handleError(event.reason);
    event.preventDefault();
  };
};
```

##### 3.3.7 APIè¯·æ±‚å¼‚å¸¸æ‹¦æˆªå™¨

```typescript
// frontend/utils/apiInterceptor.ts
import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import { UnauthorizedError, ForbiddenError, NotFoundError, NetworkError } from '@/shared/errors';
import { createErrorHandler } from './errorHandler';

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL,
  timeout: 30000,
});

const errorHandler = createErrorHandler({
  showError: (message) => {
    alert(message);
  },
  showNotification: (message, type) => {
    console.log(`[${type}] ${message}`);
  },
  redirectTo: (path) => {
    window.location.href = path;
  },
  logError: (error) => {
    console.error('API error:', error);
  },
});

apiClient.interceptors.request.use(
  (config: AxiosRequestConfig) => {
    const token = localStorage.getItem('authToken');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response: AxiosResponse) => {
    return response;
  },
  async (error: AxiosError) => {
    const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };

    if (error.response) {
      const { status, data } = error.response;

      switch (status) {
        case 401:
          if (!originalRequest._retry) {
            originalRequest._retry = true;
            try {
              const newToken = await refreshToken();
              if (newToken && originalRequest.headers) {
                localStorage.setItem('authToken', newToken);
                originalRequest.headers.Authorization = `Bearer ${newToken}`;
                return apiClient(originalRequest);
              }
            } catch (refreshError) {
              errorHandler.handleError(new UnauthorizedError());
            }
          }
          errorHandler.handleError(new UnauthorizedError());
          break;

        case 403:
          errorHandler.handleError(new ForbiddenError());
          break;

        case 404:
          errorHandler.handleError(new NotFoundError('Resource'));
          break;

        case 500:
          errorHandler.handleError(new Error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'));
          break;

        default:
          const errorMessage = (data as any)?.message || 'è¯·æ±‚å¤±è´¥';
          errorHandler.handleError(new Error(errorMessage));
      }
    } else if (error.request) {
      errorHandler.handleError(new NetworkError('ç½‘ç»œè¯·æ±‚å¤±è´¥'));
    } else {
      errorHandler.handleError(new Error('è¯·æ±‚é…ç½®é”™è¯¯'));
    }

    return Promise.reject(error);
  }
);

async function refreshToken(): Promise<string> {
  const response = await axios.post('/api/auth/refresh', {
    refreshToken: localStorage.getItem('refreshToken'),
  });
  return response.data.token;
}

export default apiClient;
```

#### 3.4 åç«¯å¼‚å¸¸å¤„ç†å®ç°

##### 3.4.1 åç«¯å…¨å±€å¼‚å¸¸å¤„ç†å™¨

```typescript
// backend/middleware/error.middleware.ts
import { Context, Next } from 'hono';
import { ZodError } from 'zod';
import { BaseError, ValidationError, NotFoundError, UnauthorizedError, ForbiddenError } from '@/shared/errors';

export const errorMiddleware = async (c: Context, next: Next) => {
  try {
    await next();
  } catch (error) {
    return handleError(c, error);
  }
};

function handleError(c: Context, error: unknown) {
  console.error('Backend Error:', error);

  if (error instanceof BaseError) {
    return c.json(
      {
        success: false,
        error: {
          code: error.code,
          message: error.message,
          context: error.context,
        },
      },
      error.statusCode
    );
  }

  if (error instanceof ZodError) {
    return c.json(
      {
        success: false,
        error: {
          code: 'YYC3-ERROR-VALIDATION-001',
          message: error.errors[0].message,
          details: error.errors,
        },
      },
      400
    );
  }

  if (error instanceof Error) {
    return c.json(
      {
        success: false,
        error: {
          code: 'YYC3-ERROR-SYSTEM-001',
          message: process.env.NODE_ENV === 'development' ? error.message : 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
        },
      },
      500
    );
  }

  return c.json(
    {
      success: false,
      error: {
        code: 'YYC3-ERROR-UNKNOWN-001',
        message: 'å‘ç”ŸæœªçŸ¥é”™è¯¯',
      },
    },
    500
  );
}
```

##### 3.4.2 å¼‚å¸¸æ—¥å¿—è®°å½•å™¨

```typescript
// backend/utils/logger.ts
import { BaseError } from '@/shared/errors';

export class Logger {
  private static instance: Logger;
  private logs: Array<{
    timestamp: Date;
    level: 'info' | 'warn' | 'error';
    message: string;
    error?: Error;
    context?: Record<string, any>;
  }> = [];

  private constructor() {}

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  info(message: string, context?: Record<string, any>): void {
    this.log('info', message, undefined, context);
  }

  warn(message: string, context?: Record<string, any>): void {
    this.log('warn', message, undefined, context);
  }

  error(message: string, error?: Error, context?: Record<string, any>): void {
    this.log('error', message, error, context);
  }

  private log(
    level: 'info' | 'warn' | 'error',
    message: string,
    error?: Error,
    context?: Record<string, any>
  ): void {
    const logEntry = {
      timestamp: new Date(),
      level,
      message,
      error,
      context,
    };

    this.logs.push(logEntry);

    const logMessage = `[${logEntry.timestamp.toISOString()}] [${level.toUpperCase()}] ${message}`;

    if (error) {
      console.error(logMessage, error);
      if (error.stack) {
        console.error(error.stack);
      }
    } else {
      console.log(logMessage);
    }

    if (context) {
      console.log('Context:', JSON.stringify(context, null, 2));
    }
  }

  getLogs(): Array<{
    timestamp: Date;
    level: 'info' | 'warn' | 'error';
    message: string;
    error?: Error;
    context?: Record<string, any>;
  }> {
    return [...this.logs];
  }

  clearLogs(): void {
    this.logs = [];
  }
}

export const logger = Logger.getInstance();
```

##### 3.4.3 æœåŠ¡å±‚å¼‚å¸¸å¤„ç†ç¤ºä¾‹

```typescript
// backend/services/user.service.ts
import { userRepository } from '@/repositories/user.repository';
import { ValidationError, NotFoundError, ConflictError } from '@/shared/errors';
import { logger } from '@/utils/logger';

export class UserService {
  async createUser(data: CreateUserParams) {
    try {
      logger.info('Creating user', { email: data.email });

      const existingUser = await userRepository.findByEmail(data.email);
      if (existingUser) {
        throw new ConflictError('é‚®ç®±å·²è¢«æ³¨å†Œ');
      }

      const user = await userRepository.create(data);
      logger.info('User created successfully', { userId: user.userId });

      return user;
    } catch (error) {
      logger.error('Failed to create user', error as Error, { email: data.email });
      throw error;
    }
  }

  async getUserById(userId: string) {
    try {
      logger.info('Fetching user', { userId });

      const user = await userRepository.findById(userId);
      if (!user) {
        throw new NotFoundError('User', userId);
      }

      return user;
    } catch (error) {
      logger.error('Failed to fetch user', error as Error, { userId });
      throw error;
    }
  }
}
```

##### 3.4.4 æ•°æ®åº“å¼‚å¸¸å¤„ç†

```typescript
// backend/repositories/base.repository.ts
import { DatabaseError } from '@/shared/errors';
import { logger } from '@/utils/logger';

export class BaseRepository {
  protected handleDatabaseError(error: unknown, query?: string): never {
    logger.error('Database error', error as Error, { query });

    if (error instanceof Error) {
      throw new DatabaseError(error.message, query);
    }

    throw new DatabaseError('Unknown database error', query);
  }

  protected async executeQuery<T>(query: string, params?: any[]): Promise<T> {
    try {
      return await this.db.query(query, params);
    } catch (error) {
      this.handleDatabaseError(error, query);
    }
  }
}
```

##### 3.4.5 å¤–éƒ¨æœåŠ¡å¼‚å¸¸å¤„ç†

```typescript
// backend/services/ai.service.ts
import axios, { AxiosError } from 'axios';
import { ExternalServiceError } from '@/shared/errors';
import { logger } from '@/utils/logger';

export class AIService {
  private readonly baseUrl: string;
  private readonly apiKey: string;

  constructor() {
    this.baseUrl = process.env.AI_SERVICE_URL || '';
    this.apiKey = process.env.AI_SERVICE_API_KEY || '';
  }

  async generateScript(prompt: string): Promise<string> {
    try {
      logger.info('Calling AI service', { prompt: prompt.substring(0, 50) });

      const response = await axios.post(
        `${this.baseUrl}/generate`,
        { prompt },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          timeout: 30000,
        }
      );

      logger.info('AI service call successful');
      return response.data.script;

    } catch (error) {
      if (axios.isAxiosError(error)) {
        const axiosError = error as AxiosError;
        logger.error('AI service request failed', error, {
          url: axiosError.config?.url,
          status: axiosError.response?.status,
        });

        if (axiosError.code === 'ECONNABORTED') {
          throw new ExternalServiceError('AI Service', 'è¯·æ±‚è¶…æ—¶');
        }

        if (axiosError.response) {
          throw new ExternalServiceError(
            'AI Service',
            `æœåŠ¡è¿”å›é”™è¯¯: ${axiosError.response.status}`
          );
        }

        throw new ExternalServiceError('AI Service', 'ç½‘ç»œè¿æ¥å¤±è´¥');
      }

      logger.error('AI service error', error as Error);
      throw new ExternalServiceError('AI Service', 'æœªçŸ¥é”™è¯¯');
    }
  }
}
```

#### 3.5 å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ

##### 3.5.1 å¼‚å¸¸å¤„ç†åŸåˆ™

1. **æ—©æ•è·ï¼Œæ—©å¤„ç†**ï¼šåœ¨å¼‚å¸¸å‘ç”Ÿçš„æœ€è¿‘å±‚çº§æ•è·å’Œå¤„ç†
2. **ä¸åæ²¡å¼‚å¸¸**ï¼šé¿å…ç©ºçš„catchå—ï¼Œè‡³å°‘è®°å½•æ—¥å¿—
3. **æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯**ï¼šé”™è¯¯æ¶ˆæ¯åº”æ¸…æ™°æè¿°é—®é¢˜
4. **åŒºåˆ†ä¸šåŠ¡å¼‚å¸¸å’ŒæŠ€æœ¯å¼‚å¸¸**ï¼šä½¿ç”¨ä¸åŒçš„é”™è¯¯ç±»å‹
5. **ä¿æŒå¼‚å¸¸é“¾**ï¼šä½¿ç”¨causeæˆ–stack traceä¿ç•™åŸå§‹é”™è¯¯ä¿¡æ¯
6. **ç»Ÿä¸€é”™è¯¯å“åº”æ ¼å¼**ï¼šAPIé”™è¯¯å“åº”æ ¼å¼ä¿æŒä¸€è‡´
7. **è®°å½•è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡**ï¼šé”™è¯¯æ—¥å¿—åº”åŒ…å«è¶³å¤Ÿçš„è°ƒè¯•ä¿¡æ¯
8. **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤**ï¼šé¿å…åœ¨é”™è¯¯æ¶ˆæ¯ä¸­æš´éœ²æ•æ„Ÿä¿¡æ¯

##### 3.5.2 å¼‚å¸¸å¤„ç†æ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰å…¬å…±æ–¹æ³•éƒ½å®šä¹‰äº†å¯èƒ½æŠ›å‡ºçš„å¼‚å¸¸
- [ ] æ‰€æœ‰å¼‚å¸¸éƒ½æœ‰å¯¹åº”çš„é”™è¯¯ç 
- [ ] å¼‚å¸¸æ¶ˆæ¯æ¸…æ™°ä¸”ç”¨æˆ·å‹å¥½
- [ ] æ•æ„Ÿä¿¡æ¯ä¸åŒ…å«åœ¨å¼‚å¸¸æ¶ˆæ¯ä¸­
- [ ] æ‰€æœ‰å¼‚å¸¸éƒ½è¢«è®°å½•åˆ°æ—¥å¿—ç³»ç»Ÿ
- [ ] å‰ç«¯å®ç°äº†å…¨å±€å¼‚å¸¸å¤„ç†å™¨
- [ ] åç«¯å®ç°äº†å…¨å±€å¼‚å¸¸ä¸­é—´ä»¶
- [ ] APIå“åº”æ ¼å¼ç»Ÿä¸€ä¸”è§„èŒƒ
- [ ] é”™è¯¯è¾¹ç•Œç»„ä»¶æ­£ç¡®é…ç½®
- [ ] å¼‚å¸¸é‡è¯•æœºåˆ¶åˆç†é…ç½®
- [ ] å¤–éƒ¨æœåŠ¡è°ƒç”¨æœ‰è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
- [ ] æ•°æ®åº“æ“ä½œæœ‰äº‹åŠ¡å›æ»šæœºåˆ¶

##### 3.5.3 å¼‚å¸¸ç›‘æ§ä¸å‘Šè­¦

```typescript
// backend/utils/errorMonitor.ts
import { logger } from './logger';

interface ErrorMetrics {
  totalErrors: number;
  errorsByType: Record<string, number>;
  errorsByEndpoint: Record<string, number>;
  recentErrors: Array<{
    timestamp: Date;
    type: string;
    message: string;
    endpoint?: string;
  }>;
}

export class ErrorMonitor {
  private static instance: ErrorMonitor;
  private metrics: ErrorMetrics = {
    totalErrors: 0,
    errorsByType: {},
    errorsByEndpoint: {},
    recentErrors: [],
  };

  private constructor() {}

  static getInstance(): ErrorMonitor {
    if (!ErrorMonitor.instance) {
      ErrorMonitor.instance = new ErrorMonitor();
    }
    return ErrorMonitor.instance;
  }

  recordError(error: Error, endpoint?: string): void {
    const errorType = error.constructor.name;

    this.metrics.totalErrors++;
    this.metrics.errorsByType[errorType] = (this.metrics.errorsByType[errorType] || 0) + 1;

    if (endpoint) {
      this.metrics.errorsByEndpoint[endpoint] = (this.metrics.errorsByEndpoint[endpoint] || 0) + 1;
    }

    this.metrics.recentErrors.push({
      timestamp: new Date(),
      type: errorType,
      message: error.message,
      endpoint,
    });

    if (this.metrics.recentErrors.length > 100) {
      this.metrics.recentErrors.shift();
    }

    this.checkAlertThresholds(errorType, endpoint);
  }

  private checkAlertThresholds(errorType: string, endpoint?: string): void {
    const errorCount = this.metrics.errorsByType[errorType] || 0;
    const threshold = 10;

    if (errorCount >= threshold) {
      logger.warn(`Error threshold exceeded for type: ${errorType}`, {
        count: errorCount,
        threshold,
      });

      this.sendAlert(errorType, errorCount, endpoint);
    }
  }

  private sendAlert(errorType: string, count: number, endpoint?: string): void {
    const alertMessage = `Error Alert: ${errorType} occurred ${count} times${endpoint ? ` on ${endpoint}` : ''}`;
    console.log('ğŸš¨', alertMessage);

    // è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„å‘Šè­¦ç³»ç»Ÿï¼Œå¦‚ï¼š
    // - å‘é€é‚®ä»¶
    // - å‘é€Slackæ¶ˆæ¯
    // - è°ƒç”¨PagerDuty API
    // - å‘é€çŸ­ä¿¡é€šçŸ¥
  }

  getMetrics(): ErrorMetrics {
    return { ...this.metrics };
  }

  resetMetrics(): void {
    this.metrics = {
      totalErrors: 0,
      errorsByType: {},
      errorsByEndpoint: {},
      recentErrors: [],
    };
  }
}

export const errorMonitor = ErrorMonitor.getInstance();
```

#### 3.6 å¼‚å¸¸å¤„ç†æµ‹è¯•

##### 3.6.1 å¼‚å¸¸å¤„ç†å•å…ƒæµ‹è¯•

```typescript
// tests/unit/errors/base.error.test.ts
import { describe, it, expect } from 'vitest';
import { BaseError } from '@/shared/errors/base.error';

describe('BaseError', () => {
  it('should create error with correct properties', () => {
    const error = new BaseError(
      'Test error message',
      'TEST-001',
      400,
      { userId: '123' }
    );

    expect(error.message).toBe('Test error message');
    expect(error.code).toBe('TEST-001');
    expect(error.statusCode).toBe(400);
    expect(error.context).toEqual({ userId: '123' });
    expect(error.name).toBe('BaseError');
    expect(error.timestamp).toBeInstanceOf(Date);
  });

  it('should serialize to JSON correctly', () => {
    const error = new BaseError('Test error', 'TEST-001', 400);
    const json = error.toJSON();

    expect(json).toMatchObject({
      name: 'BaseError',
      message: 'Test error',
      code: 'TEST-001',
      statusCode: 400,
    });
    expect(json.timestamp).toBeDefined();
  });
});
```

```typescript
// tests/unit/errors/business.error.test.ts
import { describe, it, expect } from 'vitest';
import { ValidationError, NotFoundError, UnauthorizedError, ForbiddenError } from '@/shared/errors/business.error';

describe('BusinessError', () => {
  describe('ValidationError', () => {
    it('should create validation error', () => {
      const error = new ValidationError('Email is invalid', 'email');

      expect(error.message).toBe('Email is invalid');
      expect(error.code).toBe('YYC3-ERROR-VALIDATION-001');
      expect(error.statusCode).toBe(400);
      expect(error.context?.field).toBe('email');
    });
  });

  describe('NotFoundError', () => {
    it('should create not found error with id', () => {
      const error = new NotFoundError('User', '123');

      expect(error.message).toBe('User with id 123 not found');
      expect(error.code).toBe('YYC3-ERROR-NOTFOUND-001');
      expect(error.statusCode).toBe(404);
      expect(error.context?.resource).toBe('User');
      expect(error.context?.id).toBe('123');
    });

    it('should create not found error without id', () => {
      const error = new NotFoundError('Resource');

      expect(error.message).toBe('Resource not found');
      expect(error.statusCode).toBe(404);
    });
  });

  describe('UnauthorizedError', () => {
    it('should create unauthorized error', () => {
      const error = new UnauthorizedError('Please login');

      expect(error.message).toBe('Please login');
      expect(error.code).toBe('YYC3-ERROR-UNAUTHORIZED-001');
      expect(error.statusCode).toBe(401);
    });
  });

  describe('ForbiddenError', () => {
    it('should create forbidden error', () => {
      const error = new ForbiddenError('Access denied');

      expect(error.message).toBe('Access denied');
      expect(error.code).toBe('YYC3-ERROR-FORBIDDEN-001');
      expect(error.statusCode).toBe(403);
    });
  });
});
```

```typescript
// tests/unit/frontend/errorHandler.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { FrontendErrorHandler, createErrorHandler } from '@/utils/errorHandler';
import { ValidationError, UnauthorizedError, NotFoundError } from '@/shared/errors';

describe('FrontendErrorHandler', () => {
  let mockContext: any;
  let errorHandler: FrontendErrorHandler;

  beforeEach(() => {
    mockContext = {
      showError: vi.fn(),
      showNotification: vi.fn(),
      redirectTo: vi.fn(),
      logError: vi.fn(),
    };
    errorHandler = createErrorHandler(mockContext);
  });

  it('should handle ValidationError', () => {
    const error = new ValidationError('Invalid email');
    errorHandler.handleError(error);

    expect(mockContext.showError).toHaveBeenCalledWith('Invalid email');
  });

  it('should handle UnauthorizedError', () => {
    const error = new UnauthorizedError();
    errorHandler.handleError(error);

    expect(mockContext.showNotification).toHaveBeenCalledWith('è¯·å…ˆç™»å½•', 'error');
    expect(mockContext.redirectTo).toHaveBeenCalledWith('/login');
  });

  it('should handle NotFoundError', () => {
    const error = new NotFoundError('Resource');
    errorHandler.handleError(error);

    expect(mockContext.showNotification).toHaveBeenCalledWith('èµ„æºä¸å­˜åœ¨', 'error');
    expect(mockContext.redirectTo).toHaveBeenCalledWith('/404');
  });

  it('should handle generic Error', () => {
    const error = new Error('Something went wrong');
    errorHandler.handleError(error);

    expect(mockContext.showError).toHaveBeenCalledWith('ç³»ç»Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•');
  });

  it('should handle unknown error', () => {
    errorHandler.handleError('unknown error');

    expect(mockContext.showError).toHaveBeenCalledWith('å‘ç”ŸæœªçŸ¥é”™è¯¯');
  });
});
```

```typescript
// tests/unit/backend/errorMiddleware.test.ts
import { describe, it, expect, vi } from 'vitest';
import { Hono } from 'hono';
import { errorMiddleware } from '@/middleware/error.middleware';
import { ValidationError, NotFoundError } from '@/shared/errors';

describe('Error Middleware', () => {
  it('should handle ValidationError', async () => {
    const app = new Hono();
    app.use('*', errorMiddleware);
    app.get('/test', () => {
      throw new ValidationError('Invalid data');
    });

    const res = await app.request('/test');
    const json = await res.json();

    expect(res.status).toBe(400);
    expect(json.success).toBe(false);
    expect(json.error.code).toBe('YYC3-ERROR-VALIDATION-001');
    expect(json.error.message).toBe('Invalid data');
  });

  it('should handle NotFoundError', async () => {
    const app = new Hono();
    app.use('*', errorMiddleware);
    app.get('/test', () => {
      throw new NotFoundError('User', '123');
    });

    const res = await app.request('/test');
    const json = await res.json();

    expect(res.status).toBe(404);
    expect(json.success).toBe(false);
    expect(json.error.code).toBe('YYC3-ERROR-NOTFOUND-001');
  });

  it('should handle generic Error', async () => {
    const app = new Hono();
    app.use('*', errorMiddleware);
    app.get('/test', () => {
      throw new Error('Internal error');
    });

    const res = await app.request('/test');
    const json = await res.json();

    expect(res.status).toBe(500);
    expect(json.success).toBe(false);
    expect(json.error.code).toBe('YYC3-ERROR-SYSTEM-001');
  });
});
```

#### 3.7 å¼‚å¸¸å¤„ç†æ–‡æ¡£

##### 3.7.1 å¼‚å¸¸å¤„ç†æµç¨‹å›¾

```
ç”¨æˆ·æ“ä½œ
  â†“
å‰ç«¯ç»„ä»¶
  â†“
APIè¯·æ±‚
  â†“
[å¼‚å¸¸å‘ç”Ÿï¼Ÿ]
  â”œâ”€ æ˜¯ â†’ å‰ç«¯å¼‚å¸¸å¤„ç†å™¨
  â”‚       â†“
  â”‚     åˆ¤æ–­å¼‚å¸¸ç±»å‹
  â”‚       â”œâ”€ ValidationError â†’ æ˜¾ç¤ºé”™è¯¯æç¤º
  â”‚       â”œâ”€ UnauthorizedError â†’ è·³è½¬ç™»å½•é¡µ
  â”‚       â”œâ”€ ForbiddenError â†’ è·³è½¬403é¡µ
  â”‚       â”œâ”€ NotFoundError â†’ è·³è½¬404é¡µ
  â”‚       â””â”€ å…¶ä»– â†’ æ˜¾ç¤ºé€šç”¨é”™è¯¯
  â”‚       â†“
  â”‚     è®°å½•æ—¥å¿—
  â”‚       â†“
  â”‚     ä¸ŠæŠ¥ç›‘æ§
  â”‚
  â””â”€ å¦ â†’ åç«¯æœåŠ¡
          â†“
        [å¼‚å¸¸å‘ç”Ÿï¼Ÿ]
          â”œâ”€ æ˜¯ â†’ åç«¯å¼‚å¸¸ä¸­é—´ä»¶
          â”‚       â†“
          â”‚     åˆ¤æ–­å¼‚å¸¸ç±»å‹
          â”‚       â”œâ”€ BusinessError â†’ è¿”å›ä¸šåŠ¡é”™è¯¯å“åº”
          â”‚       â”œâ”€ TechnicalError â†’ è¿”å›æŠ€æœ¯é”™è¯¯å“åº”
          â”‚       â””â”€ SystemError â†’ è¿”å›ç³»ç»Ÿé”™è¯¯å“åº”
          â”‚       â†“
          â”‚     è®°å½•æ—¥å¿—
          â”‚       â†“
          â”‚     æ›´æ–°ç›‘æ§æŒ‡æ ‡
          â”‚       â†“
          â”‚     [è¾¾åˆ°å‘Šè­¦é˜ˆå€¼ï¼Ÿ]
          â”‚         â”œâ”€ æ˜¯ â†’ å‘é€å‘Šè­¦
          â”‚         â””â”€ å¦ â†’ ç»“æŸ
          â”‚
          â””â”€ å¦ â†’ è¿”å›æˆåŠŸå“åº”
                  â†“
                å‰ç«¯å¤„ç†å“åº”
```

##### 3.7.2 å¼‚å¸¸å¤„ç†é…ç½®æ–‡ä»¶

```typescript
// shared/config/error.config.ts
export interface ErrorConfig {
  development: {
    showStackTrace: boolean;
    showDetailedErrors: boolean;
    logLevel: 'debug' | 'info' | 'warn' | 'error';
  };
  production: {
    showStackTrace: boolean;
    showDetailedErrors: boolean;
    logLevel: 'debug' | 'info' | 'warn' | 'error';
  };
  alertThresholds: {
    errorType: string;
    count: number;
    timeWindow: number;
  }[];
  retryConfig: {
    maxRetries: number;
    retryDelay: number;
    retryableErrors: string[];
  };
}

export const errorConfig: ErrorConfig = {
  development: {
    showStackTrace: true,
    showDetailedErrors: true,
    logLevel: 'debug',
  },
  production: {
    showStackTrace: false,
    showDetailedErrors: false,
    logLevel: 'error',
  },
  alertThresholds: [
    { errorType: 'DatabaseError', count: 10, timeWindow: 60000 },
    { errorType: 'ExternalServiceError', count: 5, timeWindow: 60000 },
    { errorType: 'NetworkError', count: 20, timeWindow: 60000 },
  ],
  retryConfig: {
    maxRetries: 3,
    retryDelay: 1000,
    retryableErrors: ['NetworkError', 'ExternalServiceError', 'CacheError'],
  },
};
```

---

> ã€Œ***YanYuCloudCube***ã€
> ã€Œ***<admin@0379.email>***ã€
> ã€Œ***Words Initiate Quadrants, Language Serves as Core for the Future***ã€
> ã€Œ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***ã€
